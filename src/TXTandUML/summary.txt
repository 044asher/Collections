Ответы на вопросы:
2. Изучить внутреннюю структуру коллекций, знать отличия коллекций List (ArrayList, LinkedList),
   Set (HashSet, TreeSet, LinkedHashSet), Map (HashMap, TreeMap, LinkedHashMap), Stack, Queue.

   List:

   ArrayList:
   Внутренне базируется на массиве.
   Эффективен при случайном доступе к элементам по индексу.
   Динамически увеличивает свой размер при необходимости.

   LinkedList:
   Внутренне базируется на двусвязном списке. (каждый элемент в списке содержит ссылки на
   предыдущий и следующий элементы. Это обеспечивает эффективные вставки и удаления в середине списка,
   поскольку не требуется перемещение всего списка при изменении структуры.
   Каждый узел связан с предыдущим и следующим узлом, образуя цепочку элементов.)

   Эффективен при вставках и удалениях в середине списка.
   Более затратен по памяти и может быть медленнее при случайном доступе.


   Set:
   Set принимает только значения и сам заботится об уникальности ключей элементов.

   HashSet:
   Реализован на основе хэш-таблицы.
   Не гарантирует порядок элементов.
   Позволяет быстро проверять наличие элемента.

   LinkedHashSet:
   Сочетает свойства HashSet и LinkedList.
   Сохраняет порядок вставки элементов(когда нужно множество с сохранением порядка вставки).
   (То есть HashSet выведет данные не в порядке их туда занесения, а LinkedHashSet порядок сохранит)

   TreeSet:
   Реализован на основе дерева (чаще всего красно-черного).
   Гарантирует упорядоченность элементов (в порядке возрастания).
   Эта структура данных является крайне эффективной, когда нам необходимо получить доступ к элементу
   при большом количестве элементов (в 10 раз быстрее получение элементов чем в ArrayList)




   Map:
   В Мар используются пары "ключ - значение". Ключ нужно задавать самостоятельно и он является элементом.

   HashMap:
   Реализован на основе хэш-таблицы.
   Обеспечивает постоянное время для записи и доступа к элементам.
   Позволяет хранить пары ключ-значение.
   Не гарантирует порядок элементов.
   Для инициализации требует два параметра: ключ и значение. Ключи должны быть уникальными.

   TreeMap:
   Реализован на основе дерева, что обеспечивает более высокую скорость получения данных.
   Гарантирует, что элементы будут отсортированы по возрастанию.

   LinkedHashMap:
   хранит элементы типа “ключ – значение” в том порядке, в котором они были добавлены.
   Это означает, что когда мы захотим вывести содержимое структуры данных
   мы получим их не упорядоченными по возрастанию, а в порядке добавления.




   Stack:
   Реализует структуру данных стек (Last In, First Out - LIFO).
   Обычно реализован на основе динамического массива.




   Queue:
   Реализует структуру данных очередь (First In, First Out - FIFO).
   Может быть реализована как на основе массива, так и на основе связанного списка.


                                        TreeSet vs. TreeMap:

TreeSet:                                                     TreeMap:

Особенности:                                                 Особенности:
Реализует интерфейс Set.                                     Реализует интерфейс Map.
Содержит уникальные элементы в упорядоченном виде.           Содержит пары ключ-значение в упорядоченном виде.
Основан на структуре данных красно-черного дерева.           Основан на структуре данных красно-черного дерева.

Использование:                                               Использование:
Применяется, когда нужно хранить уникальные элементы         Применяется, когда необходимо хранить
в упорядоченном порядке.                                     пары ключ-значение в упорядоченном порядке
                                                             относительно ключей.
Элементами TreeMap являются пары ключ-значение, где ключ используется для сортировки.
Для TreeSet: Как и в HashSet, вы добавляете элементы в TreeSet,
и он автоматически управляет уникальностью элементов.

                                        HashSet vs. HashMap:

HashSet:                                                     HashMap:
Содержит уникальные элементы в произвольном порядке.         Содержит пары ключ-значение в произвольном порядке.
Основан на хэш-таблице.                                      Основан на хэш-таблице.

Использование:                                               Использование:
Применяется, когда нужно хранить уникальные элементы         Применяется, когда нужно хранить пары ключ-значение
без необходимости сохранения порядка.                        без необходимости сохранения порядка ключей.

 В HashSet ключом является сам элемент, который вы добавляете в множество.
 В HashMap ключ также является элементом, но в отличие от HashSet, где элемент служит и ключом, и значением,
 в HashMap элемент связан с определенным значением.


3. Для чего нужны equals, hashCode?
Широко используются в интерфейсах Set, Map так как уникальность определяется за счет контракта hashcode() equals()
equals() предназначен для сравнения содержимого объектов на предмет равенства.

hashCode() возвращает целочисленный хэш-код объекта.
Хэш-код используется для оптимизации поиска в коллекциях, таких как HashSet и HashMap, т.е в коллекциях,
таких как HashMap, HashSet, hashCode() используется для определения местоположения объекта в хранилище данных.

Стандартный контракт hashCode():
Если a.equals(b), то a.hashCode() должен равняться b.hashCode().
Обратное не всегда верно: если a.hashCode() == b.hashCode(), это не означает, что a.equals(b).

Когда использовать:

Когда объекты должны быть сравнимыми:
Используйте equals, когда вам нужно сравнивать содержимое объектов.

Когда объекты используются в коллекциях:
Используйте hashCode, когда объекты будут использоваться в коллекциях для эффективного поиска.

При создании пользовательских классов:
В классах, которые вы создаете, переопределите equals и hashCode,
чтобы обеспечить корректное сравнение и использование в коллекциях.




4. Для чего нужны compareTo, Comparator?
compareTo и Comparator в Java используются для сравнения объектов, что часто необходимо при сортировке данных.
Оба эти метода позволяют определить порядок элементов в коллекциях, таких как списки или деревья.

compareTo - метод, определенный в интерфейсе Comparable.
Используется для сравнения текущего объекта с переданным объектом.

Возвращает отрицательное число, ноль или положительное число в зависимости от того,
является ли текущий объект меньшим, равным или большим, чем переданный объект.


Интерфейс Comparator:
позволяет определить внешний порядок сравнения для объектов.
В отличие от Comparable, Comparator не требует изменения самого класса объекта.

Можно создать несколько различных реализаций Comparator для одного класса,
что позволяет сортировать объекты по разным критериям.

Пример использования для сортировки по имени:
public static final Comparator<Person> NAME_COMPARATOR = Comparator.comparing(Person::getName);


Когда использовать:

Естественный порядок:
Используйте compareTo, когда у класса есть естественный порядок, и вы хотите определить его
внутри самого класса.

Внешний порядок:
Используйте Comparator, когда вы хотите определить несколько различных порядков для сортировки объектов,
не изменяя сами объекты. Например, сортировка по разным полям или критериям в различных сценариях.



5. Для чего нужен iterator?
Интерфейс Collection расширяет интерфейс Iterable – благодаря этому все классы наследники Collection
могут получить Итератор.
Метод интерфейса Iterable - iterator который позволяет последовательно обходить элементы коллекций
при сокрытии внутренней структуры данных от пользователя.

Итератор позволяет перемещаться по коллекции, получать или удалять элементы.
Одну и ту же коллекцию могут одновременно обходить различные итераторы.


6.Что такое immutable и mutable collection. Привести прикладные примеры создания таких коллекций.
Mutable (изменяемая) коллекция:

Mutable коллекции позволяют изменять свое содержимое после создания.
Это означает, что есть возможность добавлять, удалять или изменять элементы коллекции.


Immutable (неизменяемая) коллекция:

Immutable коллекции не позволяют изменять свое содержимое после создания.
Это означает, что, как только коллекция создана, больше нет возможности добавлять, удалять или изменять
элементы. Это может обеспечить безопасность в многопоточных сценариях и предотвращает неожиданные изменения.

Mutable Collections:
List:
ArrayList - изменяемый (mutable) список.
LinkedList - изменяемый (mutable) связанный список.

Set:
HashSet - изменяемое (mutable) множество.
TreeSet - изменяемое (mutable) множество.
LinkedHashSet - изменяемое (mutable) множество.

Map:
HashMap - изменяемая (mutable) хеш-таблица.
TreeMap - изменяемая (mutable) хеш-таблица.
LinkedHashMap - изменяемая (mutable) хеш-таблица.

Stack:
Stack - изменяемый (mutable) стек.

Queue:
LinkedList - изменяемая (mutable) реализация очереди.
ArrayDeque - изменяемая (mutable) двусторонняя очередь.

Immutable:
List:
метод List.of()
Set:
метод Set.of()
Map:
метод Map.of()
Queue:
метод List.of()


7. Что такое generics и wildcard? Привести прикладные примеры.
Generics — это параметризованные типы. С их помощью можно объявлять классы, интерфейсы и методы,
где тип данных указан в виде параметра. Обобщения добавили в язык безопасность типов.

В угловых скобках используется T — имя параметра типа. Это имя используется в качестве заполнителя,
куда будет подставлено имя реального типа, переданного классу при создании реальных типов.
То есть параметр типа T применяется в классе всякий раз, когда требуется параметр типа.
Угловые скобки указывают, что параметр может быть обобщен.
Сам класс при этом называется обобщенным классом или параметризованным типом.



Wildcards - дабы дженерики не потеряли свою главную фишку - типобезопасность, компилятор не даст
приводить один Лист, например из стрингов к Листу из других объектов так как
между объектом и коллекцией объектов есть важное различие:
Если класс Meat является наследником класса Food, то Collection<Meat> при этом — не наследник Collection<Food>.

Поэтому используем Wildcards, есть три вида - extends, super, и просто ?(любой тип).

Если extends, то значит, что метод принимает на вход коллекцию объектов класса MenuItem либо объектов
любого класса-наследника MenuItem (? extends MenuItem).

super же работает наоборот, конструкция <? super Meat> говорит компилятору, что метод iterate() может
принимать на вход коллекцию объектов класса Cat либо любого другого класса-предка Cat.

То есть extends - для всех наследников, то есть сверху вниз, super - для классов предков, или же снизу вверх.


8. Изучить устройство памяти в Java (хранение примитивных и ссылочных типов данных в памяти).
В Java, память поделена на различные области, включая стек, кучу (heap) и область методов (method area).

Стек (Stack):
Примитивные типы данных: Значения примитивных типов хранятся непосредственно в стеке. Это включает в себя
типы данных, такие как int, char, boolean и другие.

Ссылочные типы данных: В стеке хранятся только ссылки на объекты, а не сами объекты.
Таким образом, если у вас есть переменная ссылочного типа (например, Object или пользовательский класс),
то в стеке будет храниться только ссылка на объект в куче.


Куча (Heap):
Примитивные типы данных: Примитивные типы данных не хранятся в куче, если только они не являются
частью объекта. Например, если у вас есть объект Person с полем типа int, то это int будет храниться внутри
объекта в куче.

Ссылочные типы данных: Объекты и массивы всех типов данных хранятся в куче.
Память выделяется для объектов при их создании оператором new. Ссылочные переменные на объекты также
хранятся в стеке, но сами объекты располагаются в куче.

Область методов (Method Area):
В этой области хранятся метаданные классов, статические переменные, код методов и другая информация,
относящаяся к классам и методам.

9.7 Сортировки:
Сортировка выбором:
Каждый проход выбирать самый минимальный элемент и смещать его в начало.
При этом каждый новый проход начинать сдвигаясь вправо, то есть первый проход — с первого элемента,
второй проход — со второго.

--------------------------------------------------------------------------------------------------------------
Data Structure - программная единица, позволяющая хранить и обрабатывать однотипные
и/или логически связанные данные.

Основные методы Collection:
+-----------------------+------------------------------------------------------------------------+
| Метод                 | Описание                                                               |
+-----------------------+------------------------------------------------------------------------+
| add(E item)           | Добавление элемента в коллекцию. При удачном добавлении возвращает     |
|                       | true, при неудачном – false.                                           |
+-----------------------+------------------------------------------------------------------------+
| addAll(Collection<?>) | Добавляет все элементы указанной коллекции в эту коллекцию.            |
+-----------------------+------------------------------------------------------------------------+
| clear()               | Удаляет все элементы из этой коллекции.                                |
+-----------------------+------------------------------------------------------------------------+
| contains(Object)      | Возвращает true, если эта коллекция содержит указанный элемент.        |
+-----------------------+------------------------------------------------------------------------+
| containsAll(          | Возвращает true, если эта коллекция содержит все элементы              |
| Collection<?>)        | указанной коллекции.                                                   |
+-----------------------+------------------------------------------------------------------------+
| isEmpty()             | Возвращает true, если эта коллекция не содержит элементов.             |
+-----------------------+------------------------------------------------------------------------+
| remove(Object)        | Удаляет один экземпляр указанного элемента из этой коллекции, если     |
|                       | он присутствует.                                                       |
+-----------------------+------------------------------------------------------------------------+
| removeAll(            | Удаляет все элементы этой коллекции, которые содержатся в              |
| Collection<?>)        | указанной коллекции.                                                   |
+-----------------------+------------------------------------------------------------------------+
| retainAll(            | Сохраняет только те элементы в этой коллекции, которые содержатся      |
| Collection<?>)        | в указанной коллекции. Остальные элементы удаляются.                   |
+-----------------------+------------------------------------------------------------------------+
| size()                | Возвращает количество элементов в этой коллекции.                      |
+-----------------------+------------------------------------------------------------------------+
| stream()              | Возвращает последовательный поток с этой коллекцией в качестве         |
|                       | источника.                                                             |
+-----------------------+------------------------------------------------------------------------+
| toArray()             | Возвращает массив, содержащий все элементы этой коллекции.             |
+-----------------------+------------------------------------------------------------------------+


2. Изучить внутреннюю структуру коллекций, знать отличия коллекций List (ArrayList, LinkedList),
Set (HashSet, TreeSet, LinkedHashSet), Map (HashMap, TreeMap, LinkedHashMap), Stack, Queue.

Коллекция - набор интерфейсов и классов для работы с группой однотипных объектов – элементов коллекции.
В основе коллекции лежит использование интерфейса который определяет её базовый функционал.
!!! Сами же коллекции хранят только ссылки на объекты, т.е примитивные типы нельзя хранить в коллекциях.

Два главных интерфейса коллекций:
х Интерфейс Collection наследует интерфейс Iterable, который имеет один метод Iterator<T> iterator(),
позволяет последовательно обходить элементы.
х Map не наследует интерфейс Collection, но входит в состав Java Collections Framework.
Хранит данные в виде пары ключ – значение.

                                             Интерфейс List
Интерфейс List расширяет интерфейс Collection.
Используется для создания простых списков.

х Сохраняет последовательность элементов
х Элементы могут быть доступны по индексу
х Может содержать повторяющиеся элементы

Помимо Iterator списки также могут вернуть ListIterator, (5 вопрос)
который позволяет вставку и замену элементов, а также двунаправленный доступ.

Основные методы List:
+---------------------------+------------------------------------------------------------+
| Метод                     | Описание                                                   |
+---------------------------+------------------------------------------------------------+
| get(int index)            | Возвращает элемент списка по указанному индексу.           |
+---------------------------+------------------------------------------------------------+
| set(int index, Object obj)| Заменяет элемент по индексу в этом списке на указанный     |
|                           | элемент.                                                   |
+---------------------------+------------------------------------------------------------+
| indexOf(Object obj)       | Возвращает индекс первого указанного элемента в списке или |
|                           | -1, если элемент отсутствует.                              |
+---------------------------+------------------------------------------------------------+
| lastIndexOf(Object obj    | Возвращает индекс последнего вхождения указанного элемента |
|                           | или -1, если элемент отсутствует.                          |
+---------------------------+------------------------------------------------------------+
| listIterator()            | Возвращает итератор списка по элементам этого списка.      |
+---------------------------+------------------------------------------------------------+
| listIterator(int index)   | Возвращает итератор списка по элементам этого списка,      |
|                           | начиная с указанного индекса.                              |
+---------------------------+------------------------------------------------------------+
| of()                      | Возвращает неизменяемый список, содержащий ноль элементов. |
+---------------------------+------------------------------------------------------------+
| of(E e1)                  | Возвращает неизменяемый список, содержащий один элемент.   |
+---------------------------+------------------------------------------------------------+
| of(E... elements)         | Возвращает неизменяемый список, содержащий произвольное    |
|                           | количество элементов.                                      |
+---------------------------+------------------------------------------------------------+
| subList(int from, int to) | Возвращает часть коллекции от позиции from включительно до |
|                           | позиции to исключительно.                                  |
+---------------------------+------------------------------------------------------------+
| trimToSize()              | Обрезает емкость (capacity) списка до реального количества |
|                           | элементов в нем.                                           |
+---------------------------+------------------------------------------------------------+



                                         Класс ArrayList

- поддерживает динамические массивы.
По мере добавления элементов в список, емкость внутреннего массива автоматически увеличивается.

Особенности:
х Быстрый доступ к элементам по индексу.
х Медленная вставка и удаление элементов из середины.
х Быстрая вставка и удаление элементов с конца.
х Хранит любые значения, в том числе и null.
х Не синхронизирован.
х Автоматически увеличивается, но не уменьшается.

ArrayList создается с начальной емкостью capacity 10 ячеек
Переменная size хранит количество добавленных элементов и изначально равна 0.
Это не емкость внутреннего массива – емкость массива недоступна.

Если добавить в ArrayList больше элементов, чем его capacity – неявно для пользователя
произойдет вызов метода grow() и пересоздание внутреннего массива.

Алгоритм расширения внутреннего массива:
х Создается новый массив по формуле (capacity * 3) / 2 + 1
х Все элементы старого массива котируются в новый методом System.arraycopy()
х Новый массив присваивается внутренней переменной elementData
х Старый массив объявляется мусором – на него больше нет ссылки

!!! Автоматически внутренний массив не уменьшается.
Чтобы обрезать емкость списка до реального количества элементов в нем – используем метод trimToSize().
Этот метод есть только у ArrayList и отсутствует у List.



                                     Класс LinkedList

- использует для хранения двусвязный список.
Поэтому Итератор поддерживает обход в обе стороны.

Помимо интерфейса List реализует интерфейсы Dequeue и Queue.
Соединяет функциональность работы со списком и функциональность очереди.

Особенности класса LinkedList:
x Каждый элемент содержит ссылки на предыдущий и следующий элементы
x Позволяет хранить повторяющиеся объекты, в том числе null
x Быстрая вставка и удаление первого, последнего и элемента из середины списка за константное время O(1)
x Долгое время поиска позиции элемента за линейное время O(n)
x Операции поиска элемента по значению выполняются за линейное время O(n)
x Не синхронизирован

Используется когда необходимо часто добавлять или удалять элементы, особенно в начало списка.
Либо когда нужна вставка элемента в конец за гарантированное время.

Для установки ссылок на предыдущий и следующий элементы LinkedList
использует ноды – объекты своего вложенного класса Node.
Если предыдущий или следующий элемент отсутствует – значение ссылки null.
private static class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;

    Node(Node<E> prev, E element, Node<E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}

У LinkedList есть методы для работы с началом и концом списка, которых нет в ArrayList:
+----------------+------------------------------------------------------------+
| Метод          | Описание                                                   |
+----------------+------------------------------------------------------------+
| addFirst()     | Вставляет элемент в начало списка.                         |
+----------------+------------------------------------------------------------+
| addLast()      | Вставляет элемент в конец списка.                          |
+----------------+------------------------------------------------------------+
| removeFirst()  | Удаляет и возвращает первый элемент из этого списка.       |
+----------------+------------------------------------------------------------+
| removeLast()   | Удаляет и возвращает последний элемент из этого списка.    |
+----------------+------------------------------------------------------------+
Выгода использования LinkedList в работе с серединой и началом списка.
Вставка и удаление в LinkedList устроены гораздо проще,
чем в ArrayList – просто переопределятся ссылки на соседние элементы.

НО! Все элементы массива ArrayList находятся в одном блоке памяти,
и операция по сдвигу элементов массива выполняются быстрым низкоуровневым методом System.arraycopy()
Обычно весь внутренний массив попадает в кэш процессора,
поэтому элементы массива сдвигаются даже не в памяти, а в кэше.
Все это делает использование LinkedList не частым случаем.






                                          Интерфейс Set

Set – это множество однотипных элементов.
Добавляет ограничение, которое запрещает повторяющиеся элементы.

Особенности Set:
х Хранит только уникальные элементы
х Уникальность определяется за счет контракта hashcode() equals()
х Нет индексов

Можно делать три типа операций:
добавлять, удалять и проверять, есть ли во множестве элемент.
Методов get() и set() нет.




                                           Класс HashSet

Класс HashSet реализует интерфейс Set.

Особенности HashSet:
x Основан на хэш таблице(структура данных, которая позволяет хранить информацию в виде пар "ключ-значение")
x Элементы не упорядочены, порядок элементов может меняться
x Операции add(), remove(), contains() и size() за константное время O(1)
x Под капотом HashMap с заглушками значений

Название Hash происходит от понятия хэш-функции.
Хэш-функция сужает множество значений объекта до некоторого подмножества целых чисел.

Класс Object имеет метод hashCode(), который используется классом HashSet для эффективного размещения объектов,
заносимых в коллекцию.
В классах объектов, заносимых в HashSet, этот метод должен быть переопределен.

Не имеет собственной реализации – под капотом использует HashMap.
В качестве значения value HashMap используется заглушка.
Значения HashSet – это ключи внутренней HashMap.



                                        Класс LinkedHashSet

LinkedHashSet поддерживает связанный список элементов множества, в том порядке, в котором они были добавлены.
Это позволяет выполнять упорядоченную итерацию по множеству.

Особенности LinkedHashSet:
х Элементы в порядке добавления
х За счет этой особенности - работает дольше чем HashSet



                                        Интерфейс SortedSet
                                        (для ответа лишнее)

Расширяет интерфейс Set.
Описывает упорядоченное множество, отсортированное в возрастающем порядке или по порядку,
заданному реализацией интерфейса Comparator.

Особенности:
х Обеспечивает отсортированный порядок элементов
х Элементы упорядочены с использованием их естественного порядка или с помощью компаратора

Методы SortedSet:
+----------------------+--------------------------------------------------------------------+
| Метод                | Описание                                                           |
+----------------------+--------------------------------------------------------------------+
| comparator()         | Возвращает Компаратор, используемый для упорядочения элементов в   |
|                      | этом множестве, или null, если множество использует естественный   |
|                      | порядок сортировки.                                                |
+----------------------+--------------------------------------------------------------------+
| first()              | Возвращает первый элемент множества.                               |
+----------------------+--------------------------------------------------------------------+
| headSet(E toElement) | Возвращает часть множества, элементы которого строго меньше        |
|                      | переданного элемента.                                              |
+----------------------+--------------------------------------------------------------------+
| last()               | Возвращает последний элемент множества.                            |
+----------------------+--------------------------------------------------------------------+
| spliterator()        | Создает Spliterator (разделитель) над элементами в этом            |
|                      | отсортированном множестве.                                         |
+----------------------+--------------------------------------------------------------------+
| subSet(E fromElement,| Возвращает часть множества, элементы которой варьируются от        |
| E toElement)         | fromElement включительно, до toElement исключительно.              |
+----------------------+--------------------------------------------------------------------+
|tailSet(E fromElement)| Возвращает часть множества, элементы которого больше или равны     |
|                      | fromElement.                                                       |
+----------------------+--------------------------------------------------------------------+


                                          Интерфейс NavigableSet
                                           (для ответа лишнее)

Расширяет SortedSet и добавляет методы для более удобного поиска по коллекции.
+--------------------------------------------------------------------------------+
| Метод                                    | Описание                            |
+------------------------------------------+-------------------------------------+
| ceiling(E e)                             | Возвращает наименьший элемент       |
|                                          | множества, который будет            |
|                                          | больше или равен указанному         |
|                                          | элементу, или null, если такого     |
|                                          | элемента нет.                       |
+------------------------------------------+-------------------------------------+
| descendingIterator()                     | Возвращает итератор по элементам    |
|                                          | в этом множестве в порядке          |
|                                          | убывания.                           |
+------------------------------------------+-------------------------------------+
| descendingSet()                          | Возвращает элементы множества в     |
|                                          | обратном порядке.                   |
|                                          | Результирующий набор поддерживается |
|                                          | вызывающим набором (это называется  |
|                                          | backed-collection).                 |
+------------------------------------------+-------------------------------------+
| floor(E e)                               | Возвращает наибольший элемент в     |
|                                          | этом наборе, который будет          |
|                                          | меньше или равен указанному         |
|                                          | элементу, или null, если такого     |
|                                          | элемента нет.                       |
+------------------------------------------+-------------------------------------+
| headSet(E toElement)                     | Возвращает часть множества,         |
|                                          | элементы которого строго меньше     |
|                                          | переданного элемента.               |
+------------------------------------------+-------------------------------------+
| headSet(E toElement, boolean inclusive)  | Возвращает NavigableSet,            |
|                                          | включающий все элементы             |
|                                          | вызывающего набора, меньшие         |
|                                          | toElement.                          |
|                                          | Результирующий набор поддерживается |
|                                          | вызывающим набором (это называется  |
|                                          | backed-collection).                 |
+------------------------------------------+-------------------------------------+
| higher(E e)                              | Возвращает наименьший элемент в     |
|                                          | этом множестве, строго больший,     |
|                                          | чем данный элемент, или null,       |
|                                          | если такого элемента нет.           |
+------------------------------------------+-------------------------------------+
| iterator()                               | Возвращает итератор по элементам    |
|                                          | в этом множестве в порядке          |
|                                          | возрастания.                        |
+------------------------------------------+-------------------------------------+
| lower(E e)                               | Возвращает наибольший элемент в     |
|                                          | этом множестве строго меньше,       |
|                                          | чем данный элемент, или null,       |
|                                          | если такого элемента нет.           |
+------------------------------------------+-------------------------------------+
| pollFirst()                              | Получает и удаляет первый элемент   |
|                                          | или возвращает null, если это       |
|                                          | множество пустое.                   |
+------------------------------------------+-------------------------------------+
| pollLast()                               | Получает и удаляет последний        |
|                                          | элемент или возвращает null, если   |
|                                          | это множество пустое.               |
+------------------------------------------+-------------------------------------+
| subSet(E fromElement, boolean            | Возвращает NavigableSet,            |
| fromInclusive, E toElement, boolean      | включающий все элементы             |
| toInclusive)                             | вызывающего набора, которые         |
|                                          | больше fromElement и меньше         |
|                                          | toElement. Если fromInclusive       |
|                                          | равно true, то элемент, равный      |
|                                          | fromElement, включается. Если       |
|                                          | toInclusive равно true, также       |
|                                          | включается элемент, равный          |
|                                          | toElement.                          |
+------------------------------------------+-------------------------------------+
| subSet(E fromElement, E toElement)       | Возвращает представление части      |
|                                          | этого множества, элементы           |
|                                          | которого варьируются от             |
|                                          | fromElement включительно, до        |
|                                          | toElement исключительно.            |
+------------------------------------------+-------------------------------------+
| tailSet(E fromElement)                   | Возвращает представление части      |
|                                          | этого множества, элементы           |
|                                          | которого больше или равны           |
|                                          | fromElement.                        |
+------------------------------------------+-------------------------------------+
| tailSet(E fromElement, boolean inclusive)| Возвращает представление части      |
|                                          | этого множества, элементы           |
|                                          | которого больше fromElement         |
|                                          | (или равны, если inclusive          |
|                                          | равно true).                        |
|                                          | Результирующий набор поддерживается |
|                                          | вызывающим набором (это называется  |
|                                          | backed-collection).                 |
+------------------------------------------+-------------------------------------+



                                            Класс TreeSet

Класс TreeSet реализует интерфейс NavigableSet, который поддерживает элементы
в отсортированном по возрастанию порядке.

Особенности:
Элементы хранятся в отсортированном порядке по возрастанию
x Под капотом использует TreeMap
x Для хранения объектов использует бинарное красно-черное дерево
x Сортировка происходит благодаря тому, что все добавляемые элементы реализуют интерфейсы Comparator и Comparable
x Временная сложность базовых операций add(), remove(), contains() медленнее, чем в хэш-множествах,
но быстрее, чем в списках: O(log(n))

Если TreeSet пустой – можно положить единственное значение null
При этом все операции кроме size() и clear() перестанут работать.
В непустой TreeSet положить null уже нельзя из-за вызова compareTo()






                                            Интерфейс Map
Интерфейс Map не имеет отношения к интерфейсу Collection, но тоже является частью Collections Framework.
Это объект, который сопоставляет ключи со значениями.
Каждый ключ может сопоставляться не более одного значения.

Особенности Map:
x Хранит данные парами: key – value
x Ключ всегда является уникальным
x Уникальность определяется за счет контракта hashcode() equals()
x Значения могут дублироваться
x Доступ к значениям осуществляется по ключу
x Ключ по значению получить нельзя

По умолчанию под капотом Map массив на 16 buckets (корзин)
Внутри каждого бакета данные хранятся в LinkedList
Массив автоматически расширяется: 16 – 32 – 64

Худший результат работы Map – Коллизия:
Когда все элементы попадают в один bucket и их приходится перебирать итерацией по-внутреннему LinkedList.

Для объектов-ключей важно переопределить методы equals() и hashCode()
Допускается добавление объектов без переопределения этих методов, но найти их в Map будет невозможно.

Методы Map
+-----------------------------------+------------------------------------------------------------+
| Метод                             | Описание                                                   |
+-----------------------------------+------------------------------------------------------------+
| clear()                           | Удаляет все пары ключ-значение из этой мапы.               |
+-----------------------------------+------------------------------------------------------------+
| containsKey(Object key)           | Возвращает true, если эта мапа содержит значение для       |
|                                   | указанного ключа.                                          |
+-----------------------------------+------------------------------------------------------------+
| containsValue(Object value)       | Возвращает true, если эта мапа сопоставляет один или       |
|                                   | несколько ключей с указанным значением.                    |
+-----------------------------------+------------------------------------------------------------+
| entrySet()                        | Возвращает Set сопоставлений (пар ключ-значение),          |
|                                   | содержащихся на этой карте.                                |
+-----------------------------------+------------------------------------------------------------+
| get(Object key)                   | Возвращает значение, с которым сопоставлен указанный       |
|                                   | ключ, или null.                                            |
+-----------------------------------+------------------------------------------------------------+
| getOrDefault(Object key, V        | Возвращает значение, с которым сопоставлен указанный       |
| defaultValue)                     | ключ, или defaultValue, если эта мапа не содержит значения |
|                                   | для ключа.                                                 |
+-----------------------------------+------------------------------------------------------------+
| of()                              | Возвращает неизменимую map, содержащий ноль сопоставлений. |
+-----------------------------------+------------------------------------------------------------+
| of(K k1, V v1)                    | Возвращает неизменимую map, содержащий один элемент.       |
+-----------------------------------+------------------------------------------------------------+
| ofEntries(Map.Entry<? extends K,? | Возвращает неизменяемую map, содержащую ключи и значения,  |
| extends V>... entries)            | извлеченные из данных записей.                             |
+-----------------------------------+------------------------------------------------------------+
| isEmpty()                         | Возвращает true, если эта мапа пустая (не содержит пар     |
|                                   | ключ-значение).                                            |
+-----------------------------------+------------------------------------------------------------+
| keySet()                          | Возвращает Set из ключей, содержащихся в этой мапе.        |
+-----------------------------------+------------------------------------------------------------+
| put(K key, V value)               | Связывает указанное значение с указанным ключом и кладет   |
|                                   | это сопоставление в мапу.                                  |
+-----------------------------------+------------------------------------------------------------+
| putAll(Map<? extends K,? extends  | Копирует все сопоставления с указанной мапы на эту мапу.   |
| V> m)                             |                                                            |
+-----------------------------------+------------------------------------------------------------+
| putIfAbsent(K key, V value)       | Если указанный ключ отсутствует в мапе (или сопоставлен с  |
|                                   | нулевым значением), связывает его с заданным значением,    |
|                                   | кладет пару в мапу и возвращает null, в противном случае   |
|                                   | возвращает текущее значение.                               |
+-----------------------------------+------------------------------------------------------------+
| remove(Object key)                | Удаляет значение по ключу из этой мапы, если оно           |
|                                   | присутствует.                                              |
+-----------------------------------+------------------------------------------------------------+
| remove(Object key, Object value)  | Удаляет запись для указанного ключа только в том случае,   |
|                                   | если она в настоящее время сопоставлена с указанным        |
|                                   | значением.                                                 |
+-----------------------------------+------------------------------------------------------------+
| replace(K key, V value)           | Заменяет значение для указанного ключа только в том случае,|
|                                   | если он в настоящее время уже сопоставлен с каким-либо     |
|                                   | значением.                                                 |
+-----------------------------------+------------------------------------------------------------+
| size()                            | Возвращает количество сопоставлений ключ-значение в этой   |
|                                   | мапе.                                                      |
+-----------------------------------+------------------------------------------------------------+
| values()                          | Возвращает Collection значений, содержащихся на этой карте.|
+-----------------------------------+------------------------------------------------------------+



                                          Класс HashMap

HashMap использует хэш - таблицу, в которой ключи отсортированы относительно значений их хэш-кодов.
Bucket – это элемент (ячейка) внутреннего массива HashMap.
В нем хранятся узлы Nodes.

Особенности HashMap
x Хранит значения в произвольном порядке
x Структура хранения данных: bucket (корзина)
x Ключ и значение могут быть null
x Объекты с null ключами всегда записываются в нулевую ячейку массива.

Хеш-таблица – структура данных, реализующая интерфейс ассоциативного массива
(сопоставления ключ–значение или entry), которая обеспечивает быструю вставку и поиск элементов.

Хеш-функция получает ключ, а на выходе возвращает целое число – хеш-код.
По полученному хэш-коду ключ помещается по определенному индексу хеш-таблицы.
За хеш-функцию отвечает метод hashCode()

По этой причине важно, чтобы хеш-функция вела себя последовательно и выводила один и тот же хэш-код для одинаковых входных данных. Поэтому в качестве ключей рекомендуется использовать только неизменяемые immutable типы, например класс String или Integer.

Хеш-отображение не гарантирует порядок расположения своих элементов.
Порядок, в котором элементы вводятся в хеш-отображение, не обязательно соответствует тому порядку,
в котором они извлекаются итератором.


HashMap содержит следующие свойства:
x table – внутренний массив типа Entry
x size — размер, количество добавленных элементов
x capacity – емкость, количество бакетов в хэш-таблице
x loadFactor – коэффициент загрузки, по умолчанию равен 0.75
x Показатель насколько хэш-таблица может быть заполнена до того, как ее capacity будет автоматически увеличена
x threshold – количество элементов, при достижении которого, размер хэш-таблицы увеличится в два раза.
Рассчитывается по формуле (capacity * loadFactor)


Алгоритм добавления элемента в HashMap:

x Высчитывается hashCode() ключа

x Определяется бакет (ячейка массива) в которую будет добавлен новый элемент.
Номер определяется по остатку от деления хэшкода на кол-во ячеек.
В более новых версиях Java с помощью бинарного сдвига.

x Если бакет пустой - элемент просто добавляется.

x Если бакет не пустой – элемент добавляется в LinkedList внутри бакета:

      x Ключ добавляемого элемента сравнивается с ключами в LinkedList по хэшкодам.

      x Если хэшкоды неравны – переход к следующему элементу

      x Если хэшкоды равны – ключи дополнительно сравниваются по equals()

      x Если ключи равны по equals() – перезаписывается value найденного ключа

      x Если ключи не равны по equals() – переход к следующему элементу

x Если ключ не найден в LinkedList – элемент добавляется в конец списка





                                        Класс LinkedHashMap

LinkedHashMap расширяет HashMap.
Поддерживает связанный список записей в том порядке, в котором они добавлены.
Это позволяет организовать итерацию по карте в порядке вставки.
Элементы хранятся в порядке добавления!



                                           Класс TreeMap

Структура хранения данных красно-черное сбалансированное дерево.
По-умолчанию TreeMap сортируется по ключам с использованием принципа натуральной сортировки,
но это поведение может быть настроено под конкретную задачу при помощи объекта класса Comparator.

Особенности:
х Красно-черное сбалансированное дерево
х Все элементы отсортированы в порядке возрастания ключа
х Порядок сортировки может быть задан Comparator и Comparable

Если TreeMap пустой – можно положить единственный ключ null
При этом все операции кроме size() и clear() перестанут работать
В непустой TreeMap положить null ключ уже нельзя из-за вызова compareTo()




                                          Класс Stack

Класс Stack является подклассом Vector(является реализацией динамического массива – похож на ArrayList.
Но в отличие от ArrayList, класс Vector синхронизирован, а размер его внутреннего массива
увеличивается в 2 раза.).

Представляет собой стек объектов last-in-first-out (LIFO).

Расширяет класс Vector пятью методами, которые позволяют рассматривать вектор как стек.
Предусмотрены обычные операции push() и pop(), а также метод просмотра верхнего элемента в стеке,
метод проверки пуст ли стек, и метод поиска элемента в стеке и определения того, как далеко он находится сверху.

Методы Stack
+---------------+------------------------------------------------------------+
| Метод         | Описание                                                   |
+---------------+------------------------------------------------------------+
| empty()       | Проверяет, пуст ли этот стек.                              |
+---------------+------------------------------------------------------------+
| peek()        | Смотрит на объект в верхней части этого стека, не удаляя   |
|               | его из стека.                                              |
+---------------+------------------------------------------------------------+
| pop()         | Удаляет объект в верхней части этого стека и возвращает    |
|               | этот объект.                                               |
+---------------+------------------------------------------------------------+
| push(E item)  | Кладет элемент в стек сверху.                              |
+---------------+------------------------------------------------------------+
| search(Object | Ищет элемент в стеке. Если найден, возвращается его        |
| o)            | смещение от вершины стека. В противном случае возвращается |
|               | 1.                                                         |
+---------------+------------------------------------------------------------+



                                             Интерфейс Queue

Интерфейс Queue расширяет Collection.
Определяет поведение класса в качестве однонаправленной очереди.
Работает по принципу first-in-first-out (FIFO).

Не может хранить значение null.
Определяет основные методы для работы с однонаправленными очередями:
+--------------+------------------------------------------------------------------+
| Метод        | Описание                                                         |
+--------------+------------------------------------------------------------------+
| add(E e)     | Добавляет указанный элемент в эту очередь, если это возможно     |
|              | сделать не нарушая ограничения емкости, возвращая true в случае  |
|              | успеха и выдавая исключение IllegalStateException, если в        |
|              | настоящее время нет свободного места.                            |
+--------------+------------------------------------------------------------------+
| element()    | Получает, но не удаляет верхний элемент этой очереди. Если       |
|              | очередь пуста, бросает исключение NoSuchElementException.        |
+--------------+------------------------------------------------------------------+
| offer(E e)   | Вставляет указанный элемент в очередь, если это возможно сделать |
|              | не нарушая ограничений пропускной способности.                   |
+--------------+------------------------------------------------------------------+
| peek()       | Получает, но не удаляет верхний элемент очереди или возвращает   |
|              | null, если эта пуста.                                            |
+--------------+------------------------------------------------------------------+
| poll()       | Получает и удаляет верхний элемент очереди или возвращает null,  |
|              | если эта пуста.                                                  |
+--------------+------------------------------------------------------------------+
| remove()     | Удаляет верхний элемент очереди. Если очередь пуста, бросает     |
|              | исключение NoSuchElementException.                               |
+--------------+------------------------------------------------------------------+








5. Iterator.
Интерфейс Collection расширяет интерфейс Iterable – благодаря этому все классы наследники Collection
могут получить Итератор.
Метод интерфейса Iterable - iterator который позволяет последовательно обходить элементы коллекций
при сокрытии внутренней структуры данных от пользователя.

Итератор позволяет перемещаться по коллекции, получать или удалять элементы.
Одну и ту же коллекцию могут одновременно обходить различные итераторы.

Методы Iterator:
+-------------------------+---------------------------------------------------------------------+
| Метод                   | Описание                                                            |
+-------------------------+---------------------------------------------------------------------+
| forEachRemaining(...)   | Выполняет данное действие для каждого оставшегося элемента до тех   |
|                         | пор, пока все элементы не будут обработаны или действие не выдаст   |
|                         | исключение.                                                         |
+-------------------------+---------------------------------------------------------------------+
| hasNext()               | Возвращает true, если итерация содержит следующий элемент. Не       |
|                         | передвигает указатель итератора.                                    |
+-------------------------+---------------------------------------------------------------------+
| next()                  | Передвигает указатель на следующий элемент и возвращает его. Если   |
|                         | элемент отсутствует, бросает исключение NoSuchElementException.     |
+-------------------------+---------------------------------------------------------------------+
| remove()                | Удаляет из коллекции последний элемент, возвращенный методом next().|
+-------------------------+---------------------------------------------------------------------+
Интерфейс ListIterator
Расширяет Iterator, позволяет обойти List в обоих направлениях и изменить элементы списка.
Доступен только для коллекций, которые реализуют List.

Методы ListIterator
+-----------------+----------------------------------------------------------------+
| Метод           | Описание                                                       |
+-----------------+----------------------------------------------------------------+
| add(E e)        | Вставляет указанный элемент в список перед элементом, который  |
|                 | должен быть возвращен следующим вызовом next().                |
+-----------------+----------------------------------------------------------------+
| hasNext()       | Возвращает true, если есть следующий элемент.                  |
+-----------------+----------------------------------------------------------------+
| hasPrevious()   | Возвращает true, если есть предыдущий элемент.                 |
+-----------------+----------------------------------------------------------------+
| next()          | Возвращает следующий элемент в списке и перемещает положение   |
|                 | курсора.                                                       |
+-----------------+----------------------------------------------------------------+
| nextIndex()     | Возвращает индекс следующего элемента.                         |
+-----------------+----------------------------------------------------------------+
| previous()      | Возвращает предыдущий элемент в списке и перемещает положение  |
|                 | курсора назад.                                                 |
+-----------------+----------------------------------------------------------------+
| previousIndex() | Возвращает индекс предыдущего элемента.                        |
+-----------------+----------------------------------------------------------------+
| remove()        | Удаляет из списка последний элемент, который был возвращен     |
|                 | next() или previous(). Если вызван до next() или previous(),   |
|                 | бросает исключение IllegalStateException.                      |
+-----------------+----------------------------------------------------------------+
| set(E e)        | Заменяет последний элемент, возвращаемый методом next() или    |
|                 | previous(), указанным элементом.                               |
+-----------------+----------------------------------------------------------------+




                                                Red-Black Tree

 Красно-черное дерево - это сбалансированное бинарное дерево поиска,
 где каждый узел содержит информацию о ключе. Это обеспечивает упорядоченность элементов в дереве.

Красно-черное дерево – самобалансирующаяся версия двоичного поиска.
Обеспечивает логарифмическую сложность О(log(n)) операций добавления, удаления и поиска.

Верхний элемент – это корень дерева (чёрный цвет).
Все остальные элементы распределяются налево или направо в зависимости от значения хешей:
х Все левые потомки должны быть меньше корневого узла (или равны ему)

х Все правые потомки должны быть больше

х Оба потомка каждого красного узла — черные

х Все листья дерева (нижние элементы не содержащие данных) – черные

х Любой простой путь от узла-предка до листового узла-потомка содержит одинаковое число чёрных узлов.
Простой путь – это тот в котором каждый узел входит ровно по одному разу.

                                         13 (черный)
                                       /        \
                                  8 (красный)   17 (красный)
                                 /     \           /      \
                            1(черный)  11(черный) 15(черный) 25(черный)
                                                    /
                                               22(красный)
